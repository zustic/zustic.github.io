"use strict";(globalThis.webpackChunkzustic_doc=globalThis.webpackChunkzustic_doc||[]).push([[3068],{158(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>d,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>o});const r=JSON.parse('{"id":"tutorial-extras/query-middleware","title":"Middleware","description":"Request/response interception and transformation pipeline","source":"@site/docs/tutorial-extras/query-middleware.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/query-middleware","permalink":"/docs/tutorial-extras/query-middleware","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-extras/query-middleware.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3,"title":"Middleware","description":"Request/response interception and transformation pipeline"},"sidebar":"tutorialSidebar","previous":{"title":"Getting Started","permalink":"/docs/tutorial-extras/query-getting-started"},"next":{"title":"Plugins","permalink":"/docs/tutorial-extras/query-plugins"}}');var a=t(4848),i=t(8453);const s={sidebar_position:3,title:"Middleware",description:"Request/response interception and transformation pipeline"},d="Middleware System",l={},o=[{value:"Middleware Fundamentals",id:"middleware-fundamentals",level:2},{value:"Type Definition",id:"type-definition",level:3},{value:"Simple Example",id:"simple-example",level:3},{value:"Real-World Middleware Examples",id:"real-world-middleware-examples",level:2},{value:"1. Authentication Middleware",id:"1-authentication-middleware",level:3},{value:"2. Request Normalization Middleware",id:"2-request-normalization-middleware",level:3},{value:"3. Automatic Retry with Exponential Backoff",id:"3-automatic-retry-with-exponential-backoff",level:3},{value:"4. Request Deduplication Middleware",id:"4-request-deduplication-middleware",level:3},{value:"5. Rate Limiting Middleware",id:"5-rate-limiting-middleware",level:3},{value:"6. Request Timeout Middleware",id:"6-request-timeout-middleware",level:3},{value:"7. Response Caching Middleware",id:"7-response-caching-middleware",level:3},{value:"8. Error Transformation Middleware",id:"8-error-transformation-middleware",level:3},{value:"Middleware Pipeline Order",id:"middleware-pipeline-order",level:2},{value:"Execution Flow",id:"execution-flow",level:3},{value:"Production Example",id:"production-example",level:2},{value:"Using in React Component",id:"using-in-react-component",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Do&#39;s",id:"dos",level:3},{value:"Don&#39;ts",id:"donts",level:3},{value:"Advanced Patterns",id:"advanced-patterns",level:2},{value:"Conditional Middleware",id:"conditional-middleware",level:3},{value:"Middleware with State",id:"middleware-with-state",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"middleware-system",children:"Middleware System"})}),"\n",(0,a.jsx)(n.p,{children:"Middleware functions intercept requests before and after execution, allowing you to transform parameters, add headers, handle errors, or implement retry logic globally across all API endpoints."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"middleware-fundamentals",children:"Middleware Fundamentals"}),"\n",(0,a.jsxs)(n.p,{children:["Middleware follows a ",(0,a.jsx)(n.strong,{children:"pipeline pattern"})," where each middleware receives control, can perform side effects, calls ",(0,a.jsx)(n.code,{children:"next()"})," to pass to the next middleware, and can transform the result before returning."]}),"\n",(0,a.jsx)(n.h3,{id:"type-definition",children:"Type Definition"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"export type ApiMiddleware = (\n  ctx: MiddlewareContext,\n  next: () => Promise<{ data?: any; error?: any }>\n) => Promise<{ data?: any; error?: any }>\n\ntype MiddlewareContext = {\n  arg: any       // Query arguments passed to baseQuery\n  def: any       // Endpoint definition\n  get: any       // Get store state\n  set: any       // Update store state\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"simple-example",children:"Simple Example"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const logMiddleware: ApiMiddleware = async (ctx, next) => {\n  console.log('Request:', ctx.arg)\n  const start = Date.now()\n\n  const result = await next()\n\n  console.log('Response time:', Date.now() - start, 'ms')\n  return result\n}\n\nconst api = createApi({\n  baseQuery: myBaseQuery,\n  middlewares: [logMiddleware],\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => ({ url: '/users' })\n    })\n  })\n})\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"real-world-middleware-examples",children:"Real-World Middleware Examples"}),"\n",(0,a.jsx)(n.h3,{id:"1-authentication-middleware",children:"1. Authentication Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Automatically inject bearer tokens and handle token expiration:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const authMiddleware: ApiMiddleware = async (ctx, next) => {\n  // Initialize headers if not present\n  if (!ctx.arg.headers) {\n    ctx.arg.headers = {}\n  }\n\n  // Get token from secure storage\n  const token = localStorage.getItem('authToken')\n  const expiresAt = localStorage.getItem('tokenExpiresAt')\n\n  // Check if token is expired\n  if (expiresAt && Date.now() > parseInt(expiresAt)) {\n    // Token expired, clear it\n    localStorage.removeItem('authToken')\n    localStorage.removeItem('tokenExpiresAt')\n    window.location.href = '/login'\n    return { error: 'Token expired' }\n  }\n\n  // Add valid token to request\n  if (token) {\n    ctx.arg.headers.Authorization = `Bearer ${token}`\n  }\n\n  // Execute the request\n  const result = await next()\n\n  // Handle 401 Unauthorized responses\n  if (result.error?.status === 401) {\n    // Clear invalid token\n    localStorage.removeItem('authToken')\n    localStorage.removeItem('tokenExpiresAt')\n    \n    // Redirect to login\n    window.location.href = '/login'\n  }\n\n  return result\n}\n\n// Usage\nconst api = createApi({\n  baseQuery: myBaseQuery,\n  middlewares: [authMiddleware],\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => ({ url: '/users' })\n    })\n  })\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"2-request-normalization-middleware",children:"2. Request Normalization Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Add consistent headers and metadata to every request:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const requestNormalizationMiddleware: ApiMiddleware = async (ctx, next) => {\n  // Ensure headers object exists\n  if (!ctx.arg.headers) {\n    ctx.arg.headers = {}\n  }\n\n  // Add standard headers\n  ctx.arg.headers['Content-Type'] = 'application/json'\n  ctx.arg.headers['Accept'] = 'application/json'\n\n  // Add request tracking ID\n  ctx.arg.headers['X-Request-ID'] = crypto.randomUUID()\n\n  // Add timestamp\n  ctx.arg.headers['X-Timestamp'] = new Date().toISOString()\n\n  // Add app version\n  ctx.arg.headers['X-App-Version'] = '1.0.0'\n\n  // Add client info\n  ctx.arg.headers['X-Client'] = 'web'\n\n  // Ensure URL has API version prefix\n  if (ctx.arg.url && !ctx.arg.url.includes('/api/v')) {\n    ctx.arg.url = `/api/v1${ctx.arg.url}`\n  }\n\n  // Execute request with normalized headers\n  return await next()\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"3-automatic-retry-with-exponential-backoff",children:"3. Automatic Retry with Exponential Backoff"}),"\n",(0,a.jsx)(n.p,{children:"Implement resilient error recovery:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const retryMiddleware: ApiMiddleware = async (ctx, next) => {\n  const MAX_RETRIES = 3\n  const BASE_DELAY = 1000 // 1 second\n\n  let lastError\n\n  for (let attempt = 0; attempt < MAX_RETRIES; attempt++) {\n    const result = await next()\n\n    // Success - return immediately\n    if (!result.error) {\n      return result\n    }\n\n    // Don't retry client errors (4xx)\n    if (result.error?.status >= 400 && result.error?.status < 500) {\n      return result\n    }\n\n    // Don't retry last attempt\n    if (attempt === MAX_RETRIES - 1) {\n      return result\n    }\n\n    lastError = result.error\n\n    // Calculate exponential backoff delay\n    const delay = BASE_DELAY * Math.pow(2, attempt)\n    console.log(\n      `\u23f3 Retry attempt ${attempt + 1}/${MAX_RETRIES} in ${delay}ms`\n    )\n\n    // Wait before next attempt\n    await new Promise(resolve => setTimeout(resolve, delay))\n  }\n\n  return { error: lastError }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"4-request-deduplication-middleware",children:"4. Request Deduplication Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Prevent duplicate concurrent requests for the same endpoint:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const deduplicationMiddleware: ApiMiddleware = (() => {\n  // Track pending requests\n  const pendingRequests = new Map<\n    string,\n    Promise<{ data?: any; error?: any }>\n  >()\n\n  return async (ctx, next) => {\n    // Create unique key from URL and method\n    const requestKey = JSON.stringify({\n      url: ctx.arg.url,\n      method: ctx.arg.method || 'GET',\n      // Include body in key for POST/PUT requests\n      ...(ctx.arg.body && { body: ctx.arg.body })\n    })\n\n    // If request is already pending, return existing promise\n    if (pendingRequests.has(requestKey)) {\n      console.log('\u26a1 Deduped request:', requestKey)\n      return pendingRequests.get(requestKey)!\n    }\n\n    // Create new request\n    const promise = next()\n\n    // Store promise while pending\n    pendingRequests.set(requestKey, promise)\n\n    try {\n      const result = await promise\n      return result\n    } finally {\n      // Remove from pending after completion\n      pendingRequests.delete(requestKey)\n    }\n  }\n})()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"5-rate-limiting-middleware",children:"5. Rate Limiting Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Throttle requests to respect API rate limits:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const rateLimitMiddleware: ApiMiddleware = (() => {\n  let requestCount = 0\n  let windowStart = Date.now()\n  const MAX_REQUESTS_PER_MINUTE = 60\n  const WINDOW_SIZE = 60000 // 1 minute\n\n  return async (ctx, next) => {\n    const now = Date.now()\n    const windowElapsed = now - windowStart\n\n    // Reset window if time elapsed\n    if (windowElapsed > WINDOW_SIZE) {\n      requestCount = 0\n      windowStart = now\n      console.log(' Rate limit window reset')\n    }\n\n    // Check if at limit\n    if (requestCount >= MAX_REQUESTS_PER_MINUTE) {\n      const waitTime = WINDOW_SIZE - windowElapsed\n      console.log(\n        `\u23f8\ufe0f  Rate limit reached. Waiting ${waitTime}ms...`\n      )\n      await new Promise(resolve => setTimeout(resolve, waitTime))\n      requestCount = 0\n      windowStart = Date.now()\n    }\n\n    // Increment counter and execute\n    requestCount++\n    return await next()\n  }\n})()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"6-request-timeout-middleware",children:"6. Request Timeout Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Add timeout protection to prevent hanging requests:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const timeoutMiddleware: ApiMiddleware = async (ctx, next) => {\n  const TIMEOUT = 30000 // 30 seconds\n\n  return Promise.race([\n    next(),\n    new Promise<{ error: string }>((resolve) =>\n      setTimeout(\n        () => {\n          console.error('\u23f1\ufe0f  Request timeout:', ctx.arg.url)\n          resolve({ error: 'Request timeout' })\n        },\n        TIMEOUT\n      )\n    ),\n  ])\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"7-response-caching-middleware",children:"7. Response Caching Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Implement custom caching logic beyond built-in caching:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const cacheMiddleware: ApiMiddleware = (() => {\n  const cache = new Map<string, { data: any; time: number }>()\n  const CACHE_DURATION = 5 * 60 * 1000 // 5 minutes\n\n  return async (ctx, next) => {\n    const cacheKey = JSON.stringify({ url: ctx.arg.url, method: ctx.arg.method })\n\n    // Only cache GET requests\n    if (ctx.arg.method && ctx.arg.method !== 'GET') {\n      return await next()\n    }\n\n    // Check cache\n    const cached = cache.get(cacheKey)\n    if (cached && Date.now() - cached.time < CACHE_DURATION) {\n      console.log('\ud83d\udcbe Cache hit:', cacheKey)\n      return { data: cached.data }\n    }\n\n    // Fetch fresh data\n    const result = await next()\n\n    // Cache successful responses\n    if (!result.error) {\n      cache.set(cacheKey, { data: result.data, time: Date.now() })\n      console.log('\ud83d\udcbe Cached response:', cacheKey)\n    }\n\n    return result\n  }\n})()\n"})}),"\n",(0,a.jsx)(n.h3,{id:"8-error-transformation-middleware",children:"8. Error Transformation Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Normalize errors to consistent format:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const errorTransformMiddleware: ApiMiddleware = async (ctx, next) => {\n  const result = await next()\n\n  if (result.error) {\n    // Transform various error formats to consistent structure\n    const normalizedError = {\n      message: result.error?.message || 'Unknown error',\n      status: result.error?.status || 500,\n      endpoint: ctx.arg.url,\n      timestamp: new Date().toISOString(),\n      requestId: ctx.arg.headers?.['X-Request-ID'] || 'unknown'\n    }\n\n    return { error: normalizedError }\n  }\n\n  return result\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"middleware-pipeline-order",children:"Middleware Pipeline Order"}),"\n",(0,a.jsx)(n.p,{children:"The order of middleware matters - they execute sequentially:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  middlewares: [\n    // 1. Auth first - all requests need auth\n    authMiddleware,\n    \n    // 2. Normalize requests - add headers\n    requestNormalizationMiddleware,\n    \n    // 3. Dedupe - prevent duplicate requests\n    deduplicationMiddleware,\n    \n    // 4. Rate limit - throttle if needed\n    rateLimitMiddleware,\n    \n    // 5. Timeout - protect from hanging\n    timeoutMiddleware,\n    \n    // 6. Retry - recover from failures\n    retryMiddleware,\n  ],\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => ({ url: '/users' })\n    })\n  })\n})\n"})}),"\n",(0,a.jsx)(n.h3,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{children:"Request comes in\n    \u2193\nauthMiddleware (checks token) \u2192 call next()\n    \u2193\nrequestNormalizationMiddleware (adds headers) \u2192 call next()\n    \u2193\ndeduplicationMiddleware (checks cache) \u2192 call next()\n    \u2193\nrateLimitMiddleware (checks limit) \u2192 call next()\n    \u2193\ntimeoutMiddleware (sets timeout) \u2192 call next()\n    \u2193\nretryMiddleware (executes with retry) \u2192 call next()\n    \u2193\nbaseQuery executes (actual HTTP request)\n    \u2193\nResponse flows back through middleware in reverse order\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"production-example",children:"Production Example"}),"\n",(0,a.jsx)(n.p,{children:"Complete middleware setup for production application:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"import { createApi } from 'zustic/query'\n\ninterface User {\n  id: number\n  name: string\n  email: string\n}\n\n// ============ Middleware Stack ============\n\nconst authMiddleware: ApiMiddleware = async (ctx, next) => {\n  const token = localStorage.getItem('authToken')\n  if (token && ctx.arg.headers) {\n    ctx.arg.headers.Authorization = `Bearer ${token}`\n  }\n  \n  const result = await next()\n  \n  if (result.error?.status === 401) {\n    localStorage.removeItem('authToken')\n    window.location.href = '/login'\n  }\n  \n  return result\n}\n\nconst requestNormalizationMiddleware: ApiMiddleware = async (ctx, next) => {\n  if (!ctx.arg.headers) {\n    ctx.arg.headers = {}\n  }\n  \n  ctx.arg.headers['X-Request-ID'] = crypto.randomUUID()\n  ctx.arg.headers['X-Timestamp'] = new Date().toISOString()\n  \n  return await next()\n}\n\nconst retryMiddleware: ApiMiddleware = async (ctx, next) => {\n  for (let i = 0; i < 3; i++) {\n    const result = await next()\n    \n    if (!result.error || result.error.status < 500) {\n      return result\n    }\n    \n    if (i < 2) {\n      await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000))\n    }\n  }\n  \n  return await next()\n}\n\n// ============ API Setup ============\n\nexport const api = createApi({\n  baseQuery: async (params) => {\n    try {\n      const res = await fetch(\n        `https://api.example.com${params.url}`,\n        {\n          method: params.method || 'GET',\n          headers: params.headers || {},\n          body: params.body ? JSON.stringify(params.body) : undefined,\n        }\n      )\n\n      if (!res.ok) {\n        return { error: { status: res.status, message: res.statusText } }\n      }\n\n      return { data: await res.json() }\n    } catch (error) {\n      return { error: { status: 0, message: String(error) } }\n    }\n  },\n\n  cacheTimeout: 5 * 60 * 1000,\n  \n  middlewares: [\n    authMiddleware,\n    requestNormalizationMiddleware,\n    retryMiddleware,\n  ],\n\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => ({ url: '/users' }),\n    }),\n\n    getUser: builder.query({\n      query: (id: number) => ({ url: `/users/${id}` }),\n    }),\n\n    createUser: builder.mutation({\n      query: (user: Omit<User, 'id'>) => ({\n        url: '/users',\n        method: 'POST',\n        body: user,\n      }),\n    }),\n\n    updateUser: builder.mutation({\n      query: ({ id, data }: { id: number; data: Partial<User> }) => ({\n        url: `/users/${id}`,\n        method: 'PUT',\n        body: data,\n      }),\n    }),\n\n    deleteUser: builder.mutation({\n      query: (id: number) => ({\n        url: `/users/${id}`,\n        method: 'DELETE',\n      }),\n    }),\n  }),\n})\n\nexport const {\n  useGetUsersQuery,\n  useGetUserQuery,\n  useCreateUserMutation,\n  useUpdateUserMutation,\n  useDeleteUserMutation,\n} = api\n"})}),"\n",(0,a.jsx)(n.h3,{id:"using-in-react-component",children:"Using in React Component"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",children:"import { useGetUsersQuery, useCreateUserMutation } from './api'\n\nexport function UserManagement() {\n  // Auth middleware adds token automatically\n  // Retry middleware handles transient failures\n  // Request normalization adds tracking ID\n  const { data: users, isLoading, error } = useGetUsersQuery()\n\n  const [createUser, { isLoading: isCreating }] = useCreateUserMutation()\n\n  const handleCreate = async () => {\n    const result = await createUser({\n      name: 'John Doe',\n      email: 'john@example.com',\n    })\n\n    if (!result.error) {\n      console.log(' User created:', result.data)\n    }\n  }\n\n  if (isLoading) return <div>Loading users...</div>\n  if (error) return <div>Error loading users</div>\n\n  return (\n    <div>\n      <button onClick={handleCreate} disabled={isCreating}>\n        {isCreating ? 'Creating...' : 'Create User'}\n      </button>\n\n      <table>\n        <tbody>\n          {users?.map(user => (\n            <tr key={user.id}>\n              <td>{user.name}</td>\n              <td>{user.email}</td>\n            </tr>\n          ))}\n        </tbody>\n      </table>\n    </div>\n  )\n}\n"})}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"dos",children:"Do's"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Order matters"})," \u2014 Put auth first, retry last"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Always call next()"})," \u2014 Unless you want to short-circuit"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Keep middleware focused"})," \u2014 One concern per middleware"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Handle errors gracefully"})," \u2014 Provide fallbacks"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Log for debugging"})," \u2014 Include meaningful messages"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Test in isolation"})," \u2014 Test each middleware independently"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"donts",children:"Don'ts"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't forget to return"})," \u2014 Always return the result"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't block indefinitely"})," \u2014 Use timeouts"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't mutate arguments"})," \u2014 Clone if needed"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't ignore error responses"})," \u2014 Handle them explicitly"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't create new instances"})," \u2014 Use closures for state"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Don't use for business logic"})," \u2014 Use plugins or query-level hooks"]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h2,{id:"advanced-patterns",children:"Advanced Patterns"}),"\n",(0,a.jsx)(n.h3,{id:"conditional-middleware",children:"Conditional Middleware"}),"\n",(0,a.jsx)(n.p,{children:"Apply middleware only to specific request types:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const selectiveMiddleware: ApiMiddleware = async (ctx, next) => {\n  // Only apply to mutations (POST, PUT, DELETE)\n  const isMutation = ['POST', 'PUT', 'DELETE'].includes(ctx.arg.method)\n  \n  if (!isMutation) {\n    return await next()\n  }\n\n  // Add special handling only for writes\n  console.log('\ud83d\udcdd Write operation:', ctx.arg.url)\n  return await next()\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"middleware-with-state",children:"Middleware with State"}),"\n",(0,a.jsx)(n.p,{children:"Access and update API state:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:"const stateMiddleware: ApiMiddleware = async (ctx, next) => {\n  // Get current store state\n  const currentState = ctx.get()\n  console.log('Current state:', currentState)\n\n  const result = await next()\n\n  // Update store state if needed\n  if (!result.error) {\n    ctx.set({ lastUpdated: Date.now() })\n  }\n\n  return result\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>s,x:()=>d});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);