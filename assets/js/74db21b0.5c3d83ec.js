"use strict";(globalThis.webpackChunkzustic_doc=globalThis.webpackChunkzustic_doc||[]).push([[9457],{9720(e,n,r){r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"tutorial-extras/query-advanced","title":"Advanced Features","description":"Caching strategies, optimization, and advanced patterns","source":"@site/docs/tutorial-extras/query-advanced.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/query-advanced","permalink":"/docs/tutorial-extras/query-advanced","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-extras/query-advanced.md","tags":[],"version":"current","sidebarPosition":4,"frontMatter":{"sidebar_position":4,"title":"Advanced Features","description":"Caching strategies, optimization, and advanced patterns"},"sidebar":"tutorialSidebar","previous":{"title":"Middleware & Plugins","permalink":"/docs/tutorial-extras/query-plugins-middleware"},"next":{"title":"Zustic vs Other State Management Libraries","permalink":"/docs/tutorial-extras/comparison"}}');var t=r(4848),a=r(8453);const i={sidebar_position:4,title:"Advanced Features",description:"Caching strategies, optimization, and advanced patterns"},c="Advanced Features",o={},d=[{value:"Caching System",id:"caching-system",level:2},{value:"How Caching Works",id:"how-caching-works",level:3},{value:"Cache Configuration",id:"cache-configuration",level:3},{value:"Cache Invalidation",id:"cache-invalidation",level:2},{value:"Response Transformation",id:"response-transformation",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Transform Errors",id:"transform-errors",level:3},{value:"Error Recovery with Retry",id:"error-recovery-with-retry",level:3},{value:"Dependent Queries",id:"dependent-queries",level:2},{value:"Polling for Real-Time Data",id:"polling-for-real-time-data",level:2},{value:"Batch Requests",id:"batch-requests",level:2},{value:"Memoization",id:"memoization",level:2},{value:"Selective Queries",id:"selective-queries",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"\u2705 DO",id:"-do",level:3},{value:"\u274c DON&#39;T",id:"-dont",level:3},{value:"TypeScript Support",id:"typescript-support",level:2}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"advanced-features",children:"Advanced Features"})}),"\n",(0,t.jsx)(n.p,{children:"Master advanced patterns for caching, optimization, and performance."}),"\n",(0,t.jsx)(n.h2,{id:"caching-system",children:"Caching System"}),"\n",(0,t.jsx)(n.p,{children:"Zustic Query implements a time-based caching system. Each endpoint tracks cache expiration."}),"\n",(0,t.jsx)(n.h3,{id:"how-caching-works",children:"How Caching Works"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  clashTimeout: 5 * 60 * 1000,  // Cache for 5 minutes\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => ({ url: '/users' })\n    })\n  })\n})\n\n// First call: Network request, store in cache\nconst { data: users1 } = useGetUsersQuery()\n\n// Within 5 minutes: Return cached data instantly\nconst { data: users2 } = useGetUsersQuery()\n\n// After 5 minutes: Fetch fresh data\nconst { data: users3 } = useGetUsersQuery()\n\n// Manual refetch: Bypass cache immediately\nconst { reFetch } = useGetUsersQuery()\nreFetch()  // Always fetches fresh\n"})}),"\n",(0,t.jsx)(n.h3,{id:"cache-configuration",children:"Cache Configuration"}),"\n",(0,t.jsx)(n.p,{children:"Short cache for real-time data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  clashTimeout: 1 * 60 * 1000,  // 1 minute\n  endpoints: (builder) => ({\n    getLiveStats: builder.query({\n      query: () => ({ url: '/stats' })\n    })\n  })\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"Long cache for stable data:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  clashTimeout: 30 * 60 * 1000,  // 30 minutes\n  endpoints: (builder) => ({\n    getCountries: builder.query({\n      query: () => ({ url: '/countries' })\n    })\n  })\n})\n"})}),"\n",(0,t.jsx)(n.p,{children:"No cache - always fresh:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  clashTimeout: 0,  // Disable cache\n  endpoints: (builder) => ({\n    getRandomNumber: builder.query({\n      query: () => ({ url: '/random' })\n    })\n  })\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"cache-invalidation",children:"Cache Invalidation"}),"\n",(0,t.jsx)(n.p,{children:"Force refresh and bypass cache:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export function UsersList() {\n  const { data, reFetch, isLoading } = useGetUsersQuery()\n\n  const handleRefresh = () => {\n    reFetch()  // Bypass cache, fetch fresh data\n  }\n\n  return (\n    <div>\n      <button onClick={handleRefresh} disabled={isLoading}>\n        {isLoading ? 'Refreshing...' : '\ud83d\udd04 Refresh'}\n      </button>\n      <ul>\n        {data?.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"response-transformation",children:"Response Transformation"}),"\n",(0,t.jsx)(n.p,{children:"Transform API responses to app format:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface ApiUser {\n  id: number\n  first_name: string\n  last_name: string\n  created_at: string\n}\n\ninterface AppUser {\n  id: number\n  fullName: string\n  joinDate: Date\n}\n\nendpoints: (builder) => ({\n  getUser: builder.query({\n    query: (id) => ({ url: `/users/${id}` }),\n\n    // Transform API format to app format\n    transformResponse: (data: ApiUser): AppUser => {\n      return {\n        id: data.id,\n        fullName: `${data.first_name} ${data.last_name}`,\n        joinDate: new Date(data.created_at)\n      }\n    }\n  })\n})\n\n// Component receives transformed data\nexport function UserDetail({ userId }: { userId: number }) {\n  const { data: user } = useGetUserQuery(userId)\n\n  return (\n    <div>\n      <h1>{user?.fullName}</h1>\n      <p>Joined: {user?.joinDate.toLocaleDateString()}</p>\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,t.jsx)(n.h3,{id:"transform-errors",children:"Transform Errors"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"endpoints: (builder) => ({\n  getUser: builder.query({\n    query: (id) => ({ url: `/users/${id}` }),\n\n    // Normalize error messages\n    transformError: (error: string) => {\n      if (error.includes('404')) return 'User not found'\n      if (error.includes('401')) return 'Unauthorized'\n      if (error.includes('500')) return 'Server error'\n      return 'An error occurred'\n    }\n  })\n})\n"})}),"\n",(0,t.jsx)(n.h3,{id:"error-recovery-with-retry",children:"Error Recovery with Retry"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const retryMiddleware = async (ctx, next) => {\n  let lastError\n\n  // Try up to 3 times\n  for (let i = 0; i < 3; i++) {\n    const result = await next()\n\n    if (!result.error) {\n      return result\n    }\n\n    lastError = result.error\n\n    // Exponential backoff: 1s, 2s, 4s\n    if (i < 2) {\n      await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000))\n    }\n  }\n\n  return { error: lastError }\n}\n\nconst api = createApi({\n  baseQuery: myBaseQuery,\n  middlewares: [retryMiddleware],\n  endpoints: (builder) => ({\n    getUser: builder.query({\n      query: (id) => ({ url: `/users/${id}` })\n    })\n  })\n})\n"})}),"\n",(0,t.jsx)(n.h2,{id:"dependent-queries",children:"Dependent Queries"}),"\n",(0,t.jsx)(n.p,{children:"Wait for one query before fetching another:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export function UserPosts({ userId }: { userId: number }) {\n  // First query: fetch user\n  const { data: user } = useGetUserQuery(userId)\n\n  // Second query: depends on user being loaded\n  const { data: posts } = useGetUserPostsQuery(user?.id ?? 0, {\n    skip: !user  // Skip until user is loaded\n  })\n\n  return (\n    <div>\n      <h1>{user?.name}</h1>\n      {posts?.map(post => (\n        <article key={post.id}>{post.title}</article>\n      ))}\n    </div>\n  )\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"polling-for-real-time-data",children:"Polling for Real-Time Data"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { useEffect } from 'react'\n\nexport function LiveStats() {\n  const { data: stats, reFetch } = useGetStatsQuery()\n\n  // Poll every 5 seconds\n  useEffect(() => {\n    const interval = setInterval(() => {\n      reFetch()\n    }, 5000)\n\n    return () => clearInterval(interval)\n  }, [reFetch])\n\n  return <div>Count: {stats?.count}</div>\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"batch-requests",children:"Batch Requests"}),"\n",(0,t.jsx)(n.p,{children:"Reduce network requests by batching:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Problem: Multiple individual requests\nexport function Users() {\n  const { data: user1 } = useGetUserQuery(1)\n  const { data: user2 } = useGetUserQuery(2)\n  const { data: user3 } = useGetUserQuery(3)\n  // 3 separate requests\n}\n\n// Solution: Batch endpoint\nconst api = createApi({\n  baseQuery: myBaseQuery,\n  endpoints: (builder) => ({\n    getUsersBatch: builder.query({\n      query: (ids: number[]) => ({\n        url: '/users/batch',\n        method: 'POST',\n        body: { ids }\n      })\n    })\n  })\n})\n\nexport function Users() {\n  const { data: users } = useGetUsersBatchQuery([1, 2, 3])\n  // 1 request for all users\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"memoization",children:"Memoization"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"import { useMemo } from 'react'\n\nexport function UsersList() {\n  const { data: users } = useGetUsersQuery()\n\n  // Memoize expensive computations\n  const sortedUsers = useMemo(() => {\n    return users?.sort((a, b) => a.name.localeCompare(b.name)) || []\n  }, [users])\n\n  const usersByRole = useMemo(() => {\n    return users?.reduce((acc, user) => {\n      if (!acc[user.role]) acc[user.role] = []\n      acc[user.role].push(user)\n      return acc\n    }, {} as Record<string, any>) || {}\n  }, [users])\n\n  return <UserTable sorted={sortedUsers} byRole={usersByRole} />\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"selective-queries",children:"Selective Queries"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export function Dashboard() {\n  // Only fetch if admin\n  const isAdmin = useIsAdmin()\n\n  const { data: analytics } = useGetAnalyticsQuery(undefined, {\n    skip: !isAdmin\n  })\n\n  // A/B testing\n  const useNewUI = useFeatureFlag('new-ui')\n\n  const { data: legacyData } = useGetPostsQuery(undefined, {\n    skip: useNewUI\n  })\n\n  const { data: modernData } = useGetPostsV2Query(undefined, {\n    skip: !useNewUI\n  })\n\n  return <Dashboard data={modernData || legacyData} analytics={analytics} />\n}\n"})}),"\n",(0,t.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,t.jsx)(n.h3,{id:"-do",children:"\u2705 DO"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Use ",(0,t.jsx)(n.code,{children:"skip"})," option for conditional queries"]}),"\n",(0,t.jsxs)(n.li,{children:["Call ",(0,t.jsx)(n.code,{children:"reFetch()"})," to manually refetch when needed"]}),"\n",(0,t.jsx)(n.li,{children:"Transform responses for your app's data format"}),"\n",(0,t.jsxs)(n.li,{children:["Use appropriate ",(0,t.jsx)(n.code,{children:"clashTimeout"})," values"]}),"\n",(0,t.jsx)(n.li,{children:"Handle errors in component UI"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"-dont",children:"\u274c DON'T"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Don't call hooks conditionally (use ",(0,t.jsx)(n.code,{children:"skip"})," instead)"]}),"\n",(0,t.jsx)(n.li,{children:"Don't create API instances inside components"}),"\n",(0,t.jsx)(n.li,{children:"Don't forget to handle loading states"}),"\n",(0,t.jsxs)(n.li,{children:["Don't pass ",(0,t.jsx)(n.code,{children:"undefined"})," as query arguments"]}),"\n",(0,t.jsx)(n.li,{children:"Don't ignore error states in UI"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"typescript-support",children:"TypeScript Support"}),"\n",(0,t.jsx)(n.p,{children:"Full type inference with generics:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface User {\n  id: number\n  name: string\n  email: string\n}\n\nconst api = createApi({\n  baseQuery: async (params) => { /* ... */ },\n  endpoints: (builder) => ({\n    getUser: builder.query({\n      query: (id: number) => ({ url: `/users/${id}` })\n    })\n  })\n})\n\n// Hook types are inferred\nconst { data } = useGetUserQuery(123)  // data: any | undefined\n"})})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},8453(e,n,r){r.d(n,{R:()=>i,x:()=>c});var s=r(6540);const t={},a=s.createContext(t);function i(e){const n=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);