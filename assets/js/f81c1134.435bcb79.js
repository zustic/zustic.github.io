"use strict";(globalThis.webpackChunkzustic_doc=globalThis.webpackChunkzustic_doc||[]).push([[8130],{7735(e){e.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"react-state-management-guide","metadata":{"permalink":"/blog/react-state-management-guide","source":"@site/blog/2026-02-06-react-state-management-guide/index.md","title":"React State Management: A Complete Guide","description":"Comprehensive guide to React state management patterns, from Context API to modern libraries like Redux, Zustand, and Zustic.","date":"2026-02-06T00:00:00.000Z","tags":[{"inline":false,"label":"React","permalink":"/blog/tags/react","description":"React and JavaScript posts"},{"inline":false,"label":"State Management","permalink":"/blog/tags/state-management","description":"State management patterns and libraries"},{"inline":false,"label":"Guide","permalink":"/blog/tags/guide","description":"Complete guides and tutorials"}],"readingTime":3.01,"hasTruncateMarker":true,"authors":[{"name":"Zustic Team","title":"Lightweight State Management Library","url":"https://zustic.github.io","socials":{"github":"https://github.com/DeveloperRejaul","npm":"zustic"},"imageURL":"/img/logo.png","key":"zustic","page":null}],"frontMatter":{"slug":"react-state-management-guide","title":"React State Management: A Complete Guide","authors":["zustic"],"tags":["react","state-management","guide"],"description":"Comprehensive guide to React state management patterns, from Context API to modern libraries like Redux, Zustand, and Zustic.","image":"/img/logo.png"},"unlisted":false,"nextItem":{"title":"Simple State Management: Making State Easy with Zustic","permalink":"/blog/simple-state-management-made-easy"}},"content":"State management is one of the most important aspects of building scalable React applications. In this guide, we\'ll explore different approaches to managing state in React and understand why Zustic is the perfect solution for most projects.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What is State Management?\\n\\nState management is the practice of managing application data (state) in a predictable and centralized way. As your React app grows, passing props through multiple levels of components (prop drilling) becomes tedious and error-prone.\\n\\n### The Problem: Prop Drilling\\n\\n```tsx\\n// Without proper state management\\nfunction App() {\\n  const [user, setUser] = useState(null)\\n  \\n  return <Level1 user={user} setUser={setUser} />\\n}\\n\\nfunction Level1({ user, setUser }) {\\n  return <Level2 user={user} setUser={setUser} />\\n}\\n\\nfunction Level2({ user, setUser }) {\\n  return <Level3 user={user} setUser={setUser} />\\n}\\n\\nfunction Level3({ user, setUser }) {\\n  return <div>{user?.name}</div>\\n}\\n```\\n\\nThis is **prop drilling** - passing props through many intermediate components just to reach the component that needs them. It\'s verbose and hard to maintain.\\n\\n## State Management Solutions\\n\\n### 1. Context API (Built-in)\\n\\nReact\'s built-in solution using Context:\\n\\n```tsx\\nconst UserContext = createContext()\\n\\nexport function App() {\\n  const [user, setUser] = useState(null)\\n  \\n  return (\\n    <UserContext.Provider value={{ user, setUser }}>\\n      <YourApp />\\n    </UserContext.Provider>\\n  )\\n}\\n\\nfunction MyComponent() {\\n  const { user } = useContext(UserContext)\\n  return <div>{user?.name}</div>\\n}\\n```\\n\\n**Pros:** Built-in, no dependencies\\n**Cons:** Causes unnecessary re-renders, verbose, provider hell with multiple contexts\\n\\n### 2. Redux\\n\\nThe most popular state management library:\\n\\n```tsx\\n// Redux Boilerplate \ud83d\ude29\\nconst initialState = { user: null }\\n\\nconst userReducer = (state = initialState, action) => {\\n  switch(action.type) {\\n    case \'SET_USER\':\\n      return { ...state, user: action.payload }\\n    default:\\n      return state\\n  }\\n}\\n\\nconst store = createStore(userReducer)\\n\\n// In component\\nfunction MyComponent() {\\n  const user = useSelector(state => state.user)\\n  const dispatch = useDispatch()\\n  \\n  return <div>{user?.name}</div>\\n}\\n```\\n\\n**Pros:** Predictable, powerful, large ecosystem\\n**Cons:** Lots of boilerplate, steep learning curve, large bundle size (~6KB)\\n\\n### 3. Zustand\\n\\nA modern, lightweight alternative:\\n\\n```tsx\\nimport { create } from \'zustand\'\\n\\nconst useUserStore = create((set) => ({\\n  user: null,\\n  setUser: (user) => set({ user }),\\n}))\\n\\nfunction MyComponent() {\\n  const user = useUserStore((state) => state.user)\\n  const setUser = useUserStore((state) => state.setUser)\\n  \\n  return <div>{user?.name}</div>\\n}\\n```\\n\\n**Pros:** Minimal boilerplate, small size (~2KB), simple API\\n**Cons:** Smaller ecosystem, limited middleware support\\n\\n### 4. Zustic (The Best Choice \u2728)\\n\\nThe simplest and smallest state management library:\\n\\n```tsx\\nimport { create } from \'zustic\'\\n\\ntype UserStore = {\\n  user: null | { name: string }\\n  setUser: (user: any) => void\\n}\\n\\nconst useUserStore = create<UserStore>((set) => ({\\n  user: null,\\n  setUser: (user) => set({ user }),\\n}))\\n\\nfunction MyComponent() {\\n  const { user } = useUserStore()\\n  \\n  return <div>{user?.name}</div>\\n}\\n```\\n\\n**Pros:** \\n-  Smallest size (~500B)\\n-  Zero dependencies\\n-  Simplest API\\n-  Built-in middleware\\n-  Perfect TypeScript support\\n\\n## Comparison Table\\n\\n| Feature | Context API | Redux | Zustand | Zustic |\\n|---------|------------|-------|---------|--------|\\n| Size | 0B | 6KB | 2KB | **500B** |\\n| Boilerplate | Medium | High | Low | **Very Low** |\\n| Learning Curve | Medium | Hard | Easy | **Very Easy** |\\n| Performance |  Re-renders |  Good |  Good | ** Optimized** |\\n| Middleware |  No |  Yes |  Limited | ** Powerful** |\\n| DevTools |  No |  Great |  Limited |  Built-in |\\n\\n## When to Use Each\\n\\n- **Use Context API**: Simple app, learning React, don\'t need extra dependencies\\n- **Use Redux**: Enterprise app, complex state, large team, need DevTools\\n- **Use Zustand**: Modern app, want small bundle, simple API\\n- **Use Zustic**: Most projects! Simplest API, smallest size, powerful middleware\\n\\n## Key Concepts in State Management\\n\\n### 1. Single Source of Truth\\nAll app state in one place makes it predictable and debuggable.\\n\\n### 2. Immutability\\nState is never mutated directly. Always create new objects.\\n\\n### 3. Unidirectional Data Flow\\nData flows in one direction: Store \u2192 Component \u2192 User Action \u2192 Store Update\\n\\n### 4. Middleware\\nFunctions that intercept state changes for logging, persistence, validation, etc.\\n\\n## Conclusion\\n\\nFor most React projects, **Zustic is the perfect choice**:\\n\\n **Smallest bundle size** - Only ~500B\\n **Zero dependencies** - Nothing to install\\n **Simplest API** - Learn in 5 minutes\\n **Built-in middleware** - Logging, persistence, validation\\n **Perfect TypeScript** - Full type inference\\n **Production ready** - Used in real apps\\n\\nGet started: [Zustic Documentation](/docs/intro)\\n\\n---\\n\\n**What\'s your favorite state management solution? Let us know in the comments!**"},{"id":"simple-state-management-made-easy","metadata":{"permalink":"/blog/simple-state-management-made-easy","source":"@site/blog/2026-02-06-simple-state-management-made-easy/index.md","title":"Simple State Management: Making State Easy with Zustic","description":"Learn how to manage state the simple way. Zustic makes state management so easy that anyone can understand it in 5 minutes.","date":"2026-02-06T00:00:00.000Z","tags":[{"inline":false,"label":"State Management","permalink":"/blog/tags/state-management","description":"State management patterns and libraries"},{"inline":false,"label":"Zustic","permalink":"/blog/tags/zustic","description":"Posts about Zustic state management library"},{"inline":false,"label":"React","permalink":"/blog/tags/react","description":"React and JavaScript posts"},{"inline":false,"label":"Simple","permalink":"/blog/tags/simple","description":"Simple and easy-to-understand concepts"},{"inline":false,"label":"Beginners","permalink":"/blog/tags/beginners","description":"Posts for React beginners"}],"readingTime":4.42,"hasTruncateMarker":true,"authors":[{"name":"Zustic Team","title":"Lightweight State Management Library","url":"https://zustic.github.io","socials":{"github":"https://github.com/DeveloperRejaul","npm":"zustic"},"imageURL":"/img/logo.png","key":"zustic","page":null}],"frontMatter":{"slug":"simple-state-management-made-easy","title":"Simple State Management: Making State Easy with Zustic","authors":["zustic"],"tags":["state-management","zustic","react","simple","beginners"],"description":"Learn how to manage state the simple way. Zustic makes state management so easy that anyone can understand it in 5 minutes.","image":"/img/logo.png"},"unlisted":false,"prevItem":{"title":"React State Management: A Complete Guide","permalink":"/blog/react-state-management-guide"},"nextItem":{"title":"Understanding Middleware: The Power Behind State Management","permalink":"/blog/understanding-middleware-in-state-management"}},"content":"State management doesn\'t have to be complicated. In fact, most applications don\'t need the complexity of Redux. Let\'s explore how to manage state simply and effectively with Zustic.\\n\\n\x3c!-- truncate --\x3e\\n\\n## The State Management Journey\\n\\nAs React developers, we typically go through these stages:\\n\\n### Stage 1: useState (Simple Apps)\\n```tsx\\nfunction Counter() {\\n  const [count, setCount] = useState(0)\\n  \\n  return (\\n    <div>\\n      <p>Count: {count}</p>\\n      <button onClick={() => setCount(count + 1)}>+1</button>\\n    </div>\\n  )\\n}\\n```\\n\\nWorks great for single components!\\n\\n### Stage 2: Prop Drilling (Growing Apps)\\n```tsx\\nfunction App() {\\n  const [count, setCount] = useState(0)\\n  \\n  return (\\n    <Parent count={count} setCount={setCount}>\\n      <Child count={count} setCount={setCount} />\\n    </Parent>\\n  )\\n}\\n```\\n\\nPassing props through many components gets tedious.\\n\\n### Stage 3: Context API (Medium Apps)\\n```tsx\\nconst CountContext = createContext()\\n\\nfunction App() {\\n  const [count, setCount] = useState(0)\\n  \\n  return (\\n    <CountContext.Provider value={{ count, setCount }}>\\n      <Child />\\n    </CountContext.Provider>\\n  )\\n}\\n\\nfunction Child() {\\n  const { count, setCount } = useContext(CountContext)\\n  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>\\n}\\n```\\n\\nWorks, but requires providers everywhere and causes unnecessary re-renders.\\n\\n### Stage 4: State Management Library (Complex Apps)\\nThis is where Zustic shines! \u2728\\n\\n## Why Zustic is the Simplest Solution\\n\\n### Concept 1: Global Store\\nThink of your app state in one place:\\n\\n```tsx\\nimport { create } from \'zustic\'\\n\\n// Define your store\\nconst useCountStore = create((set) => ({\\n  count: 0,\\n  increment: () => set((state) => ({ count: state.count + 1 })),\\n  decrement: () => set((state) => ({ count: state.count - 1 })),\\n}))\\n\\n// Use anywhere - no providers!\\nfunction Counter() {\\n  const { count, increment, decrement } = useCountStore()\\n  \\n  return (\\n    <div>\\n      <p>Count: {count}</p>\\n      <button onClick={increment}>+1</button>\\n      <button onClick={decrement}>-1</button>\\n    </div>\\n  )\\n}\\n```\\n\\n**That\'s it!** No providers, no context, no complexity.\\n\\n### Concept 2: Multiple Stores\\nKeep your stores organized:\\n\\n```tsx\\n// User store\\nconst useUserStore = create((set) => ({\\n  user: null,\\n  setUser: (user) => set({ user }),\\n  logout: () => set({ user: null }),\\n}))\\n\\n// UI store\\nconst useUIStore = create((set) => ({\\n  isMenuOpen: false,\\n  toggleMenu: () => set((state) => ({ isMenuOpen: !state.isMenuOpen })),\\n}))\\n\\n// Cart store\\nconst useCartStore = create((set) => ({\\n  items: [],\\n  addItem: (item) => set((state) => ({ items: [...state.items, item] })),\\n  removeItem: (id) => set((state) => ({ \\n    items: state.items.filter(item => item.id !== id) \\n  })),\\n}))\\n\\n// Use them independently!\\nfunction App() {\\n  const { user } = useUserStore()\\n  const { isMenuOpen } = useUIStore()\\n  const { items } = useCartStore()\\n  \\n  return (\\n    <div>\\n      <h1>Hello {user?.name}</h1>\\n      {isMenuOpen && <Menu />}\\n      <p>Cart items: {items.length}</p>\\n    </div>\\n  )\\n}\\n```\\n\\n### Concept 3: Simple State Updates\\nUpdating state is straightforward:\\n\\n```tsx\\nconst useStore = create((set) => ({\\n  // Initial state\\n  count: 0,\\n  user: null,\\n  todos: [],\\n  \\n  // Simple updates\\n  increment: () => set((state) => ({ count: state.count + 1 })),\\n  setUser: (user) => set({ user }),\\n  \\n  // Adding to array\\n  addTodo: (todo) => set((state) => ({\\n    todos: [...state.todos, todo]\\n  })),\\n  \\n  // Removing from array\\n  removeTodo: (id) => set((state) => ({\\n    todos: state.todos.filter(t => t.id !== id)\\n  })),\\n  \\n  // Complex updates\\n  updateTodo: (id, updates) => set((state) => ({\\n    todos: state.todos.map(t => \\n      t.id === id ? { ...t, ...updates } : t\\n    )\\n  })),\\n}))\\n```\\n\\n### Concept 4: Accessing State Outside Components\\nSometimes you need state outside React:\\n\\n```tsx\\nconst useStore = create((set) => ({\\n  count: 0,\\n  increment: () => set((state) => ({ count: state.count + 1 })),\\n}))\\n\\n// In components\\nfunction Counter() {\\n  const count = useStore((state) => state.count)\\n  return <div>{count}</div>\\n}\\n\\n// Outside components - use get()\\nuseStore.setState({ count: 10 })\\nconsole.log(useStore.getState()) // { count: 10 }\\n```\\n\\n## Real-World Examples\\n\\n### Example 1: Todo App\\n```tsx\\ntype TodoStore = {\\n  todos: Array<{ id: number; text: string; done: boolean }>\\n  addTodo: (text: string) => void\\n  toggleTodo: (id: number) => void\\n  removeTodo: (id: number) => void\\n  clearDone: () => void\\n}\\n\\nconst useTodoStore = create<TodoStore>((set) => ({\\n  todos: [],\\n  \\n  addTodo: (text) => set((state) => ({\\n    todos: [...state.todos, {\\n      id: Date.now(),\\n      text,\\n      done: false,\\n    }]\\n  })),\\n  \\n  toggleTodo: (id) => set((state) => ({\\n    todos: state.todos.map(todo =>\\n      todo.id === id ? { ...todo, done: !todo.done } : todo\\n    )\\n  })),\\n  \\n  removeTodo: (id) => set((state) => ({\\n    todos: state.todos.filter(todo => todo.id !== id)\\n  })),\\n  \\n  clearDone: () => set((state) => ({\\n    todos: state.todos.filter(todo => !todo.done)\\n  })),\\n}))\\n\\n// Use in component\\nfunction TodoApp() {\\n  const { todos, addTodo, toggleTodo, removeTodo } = useTodoStore()\\n  const [input, setInput] = useState(\'\')\\n  \\n  return (\\n    <div>\\n      <input\\n        value={input}\\n        onChange={(e) => setInput(e.target.value)}\\n        placeholder=\\"Add todo...\\"\\n      />\\n      <button onClick={() => {\\n        addTodo(input)\\n        setInput(\'\')\\n      }}>\\n        Add\\n      </button>\\n      \\n      <ul>\\n        {todos.map(todo => (\\n          <li key={todo.id}>\\n            <input\\n              type=\\"checkbox\\"\\n              checked={todo.done}\\n              onChange={() => toggleTodo(todo.id)}\\n            />\\n            {todo.text}\\n            <button onClick={() => removeTodo(todo.id)}>Delete</button>\\n          </li>\\n        ))}\\n      </ul>\\n    </div>\\n  )\\n}\\n```\\n\\n### Example 2: Authentication\\n```tsx\\ntype AuthStore = {\\n  user: null | { id: number; email: string; name: string }\\n  isLoading: boolean\\n  login: (email: string, password: string) => Promise<void>\\n  logout: () => void\\n}\\n\\nconst useAuthStore = create<AuthStore>((set) => ({\\n  user: null,\\n  isLoading: false,\\n  \\n  login: async (email, password) => {\\n    set({ isLoading: true })\\n    try {\\n      const response = await fetch(\'/api/login\', {\\n        method: \'POST\',\\n        body: JSON.stringify({ email, password }),\\n      })\\n      const user = await response.json()\\n      set({ user, isLoading: false })\\n    } catch (error) {\\n      set({ isLoading: false })\\n      throw error\\n    }\\n  },\\n  \\n  logout: () => set({ user: null }),\\n}))\\n\\n// Use in component\\nfunction LoginForm() {\\n  const { login, isLoading } = useAuthStore()\\n  const [email, setEmail] = useState(\'\')\\n  const [password, setPassword] = useState(\'\')\\n  \\n  const handleSubmit = async (e) => {\\n    e.preventDefault()\\n    try {\\n      await login(email, password)\\n      // User logged in!\\n    } catch (error) {\\n      console.error(\'Login failed:\', error)\\n    }\\n  }\\n  \\n  return (\\n    <form onSubmit={handleSubmit}>\\n      <input\\n        value={email}\\n        onChange={(e) => setEmail(e.target.value)}\\n        placeholder=\\"Email\\"\\n        type=\\"email\\"\\n      />\\n      <input\\n        value={password}\\n        onChange={(e) => setPassword(e.target.value)}\\n        placeholder=\\"Password\\"\\n        type=\\"password\\"\\n      />\\n      <button disabled={isLoading}>\\n        {isLoading ? \'Logging in...\' : \'Login\'}\\n      </button>\\n    </form>\\n  )\\n}\\n```\\n\\n## Key Takeaways\\n\\n **Simple to understand** - Just JavaScript functions\\n **No boilerplate** - No actions, reducers, or providers\\n **TypeScript friendly** - Full type inference\\n **Flexible** - Works with async, nested state, arrays\\n **Fast** - Only re-renders when subscribed state changes\\n **Powerful** - Add middleware for logging, persistence, validation\\n\\n## State Management Decision Tree\\n\\n```\\nIs your app small?\\n\u251c\u2500 Yes \u2192 useState is fine\\n\u2514\u2500 No \u2192 Zustic!\\n\\nDo you need complex patterns?\\n\u251c\u2500 Yes \u2192 Zustic + middleware\\n\u2514\u2500 No \u2192 Zustic basic\\n\\nDo you need enterprise features?\\n\u251c\u2500 Yes \u2192 Consider Redux (but try Zustic first!)\\n\u2514\u2500 No \u2192 Zustic!\\n```\\n\\n## Conclusion\\n\\nState management should be simple. Zustic proves that you don\'t need complexity to have powerful, scalable state management. In fact, **simple is better**.\\n\\nStart with Zustic today and enjoy:\\n-  5-minute learning curve\\n-  Zero dependencies\\n-  ~500B bundle size\\n-  Perfect for teams\\n\\nGet started: [Zustic Installation](/docs/tutorial-basics/installation)\\n\\n---\\n\\n**Found this helpful? Check out our other blog posts on middleware and React state management!**"},{"id":"understanding-middleware-in-state-management","metadata":{"permalink":"/blog/understanding-middleware-in-state-management","source":"@site/blog/2026-02-06-understanding-middleware-in-state-management/index.md","title":"Understanding Middleware: The Power Behind State Management","description":"Deep dive into middleware patterns. Learn how middleware extends state management with logging, persistence, validation, and more.","date":"2026-02-06T00:00:00.000Z","tags":[{"inline":false,"label":"Middleware","permalink":"/blog/tags/middleware","description":"Middleware patterns and concepts"},{"inline":false,"label":"React","permalink":"/blog/tags/react","description":"React and JavaScript posts"},{"inline":false,"label":"State Management","permalink":"/blog/tags/state-management","description":"State management patterns and libraries"},{"inline":false,"label":"Zustic","permalink":"/blog/tags/zustic","description":"Posts about Zustic state management library"}],"readingTime":5.76,"hasTruncateMarker":true,"authors":[{"name":"Zustic Team","title":"Lightweight State Management Library","url":"https://zustic.github.io","socials":{"github":"https://github.com/DeveloperRejaul","npm":"zustic"},"imageURL":"/img/logo.png","key":"zustic","page":null}],"frontMatter":{"slug":"understanding-middleware-in-state-management","title":"Understanding Middleware: The Power Behind State Management","authors":["zustic"],"tags":["middleware","react","state-management","zustic"],"description":"Deep dive into middleware patterns. Learn how middleware extends state management with logging, persistence, validation, and more.","image":"/img/logo.png"},"unlisted":false,"prevItem":{"title":"Simple State Management: Making State Easy with Zustic","permalink":"/blog/simple-state-management-made-easy"}},"content":"Middleware is one of the most powerful but often misunderstood concepts in state management. In this post, we\'ll demystify middleware and show you how to use it effectively with Zustic.\\n\\n\x3c!-- truncate --\x3e\\n\\n## What is Middleware?\\n\\nMiddleware is a function that intercepts state changes and can perform side effects, validations, logging, or transformations before the state is actually updated.\\n\\nThink of it like a security checkpoint:\\n\\n```\\nUser Action \u2192 Middleware 1 \u2192 Middleware 2 \u2192 Middleware 3 \u2192 State Updated\\n```\\n\\nEach middleware can inspect, validate, or modify the action before it reaches the next middleware or the state.\\n\\n## How Middleware Works\\n\\nMiddleware in Zustic follows a simple but powerful pattern. Think of it like a pipeline:\\n\\n```\\nUser Action \u2192 Middleware 1 \u2192 Middleware 2 \u2192 Middleware 3 \u2192 setState\\n```\\n\\nEach middleware can:\\n1. See the previous state\\n2. See the update being made\\n3. Allow the update to proceed\\n4. Modify the update before it reaches the next middleware\\n5. React after the update is complete\\n\\n## Middleware Signature\\n\\nEvery middleware in Zustic follows this pattern:\\n\\n```typescript\\ntype Middleware<T> = (\\n  set: (partial: SetStateParams<T>) => void,\\n  get: () => T\\n) => (\\n  next: (partial: SetStateParams<T>) => void\\n) => (partial: SetStateParams<T>) => void\\n```\\n\\nBreaking it down:\\n1. **Outer function** receives `set` (update function) and `get` (state getter)\\n2. **Middle function** receives `next` (the next middleware or setState)\\n3. **Inner function** receives the actual update to be applied\\n\\n## Basic Logger Middleware\\n\\nHere\'s the simplest middleware - a logger:\\n\\n```typescript\\nconst loggerMiddleware = (set, get) => (next) => async (partial) => {\\n  // Log BEFORE the update\\n  const previousState = get();\\n  console.log(\'Previous state:\', previousState);\\n  console.log(\'Update:\', partial);\\n\\n  // Call the next middleware/setState\\n  await next(partial);\\n\\n  // Log AFTER the update\\n  console.log(\'New state:\', get());\\n};\\n```\\n\\nUsing it:\\n\\n```typescript\\nconst useStore = create(\\n  (set, get) => ({\\n    count: 0,\\n    increment: () => set((state) => ({ count: state.count + 1 })),\\n  }),\\n  loggerMiddleware // Add middleware here\\n);\\n\\n// Now every update is logged!\\nuseStore.setState((state) => ({ count: state.count + 1 }));\\n// Logs: Previous: {count: 0}\\n// Logs: Update: {count: 1}\\n// Logs: New: {count: 1}\\n```\\n\\n## Using Multiple Middleware\\n\\nYou can chain multiple middleware together:\\n\\n```typescript\\nconst useStore = create(\\n  (set, get) => ({\\n    count: 0,\\n    increment: () => set((state) => ({ count: state.count + 1 })),\\n  }),\\n  [loggerMiddleware, persistenceMiddleware, validationMiddleware]\\n);\\n\\n// Execution order:\\n// loggerMiddleware \u2192 persistenceMiddleware \u2192 validationMiddleware \u2192 setState\\n```\\n\\nThe order matters! Middleware execute from left to right.\\n\\n## Common Middleware Patterns\\n\\n### 1. Persistence Middleware\\n\\nAuto-save state to localStorage:\\n\\n```typescript\\nconst persistenceMiddleware = (key: string) => (set, get) => (next) => async (partial) => {\\n  // Apply the update\\n  await next(partial);\\n\\n  // Then save to localStorage\\n  try {\\n    const state = get();\\n    localStorage.setItem(key, JSON.stringify(state));\\n    console.log(\'\ud83d\udcbe Saved to localStorage\');\\n  } catch (error) {\\n    console.error(\'Failed to persist:\', error);\\n  }\\n};\\n\\n// Usage:\\nconst useStore = create(\\n  (set, get) => {\\n    // Load initial state from localStorage\\n    const saved = localStorage.getItem(\'mystore\');\\n    return {\\n      ...JSON.parse(saved || \'{}\'),\\n      count: 0,\\n      increment: () => set((state) => ({ count: state.count + 1 })),\\n    };\\n  },\\n  persistenceMiddleware(\'mystore\')\\n);\\n```\\n\\n### 2. Validation Middleware\\n\\nValidate updates before they\'re applied:\\n\\n```typescript\\nconst validationMiddleware = (set, get) => (next) => async (partial) => {\\n  const state = get();\\n  const updates = typeof partial === \'function\' ? partial(state) : partial;\\n\\n  // Validate the update\\n  if (\'age\' in updates && typeof updates.age === \'number\' && updates.age < 0) {\\n    console.error(\' Age cannot be negative!\');\\n    return; // Reject the update\\n  }\\n\\n  if (\'email\' in updates && !updates.email.includes(\'@\')) {\\n    console.error(\' Invalid email format!\');\\n    return;\\n  }\\n\\n  // Update is valid, proceed\\n  await next(partial);\\n  console.log(\' Validation passed\');\\n};\\n```\\n\\n### 3. Time Travel / History Middleware\\n\\nStore history for debugging and time-travel:\\n\\n```typescript\\nconst historyMiddleware = (set, get) => {\\n  let history: any[] = [get()];\\n  let historyIndex = 0;\\n\\n  // Expose time-travel functions\\n  if (typeof window !== \'undefined\') {\\n    (window as any).__devtools__ = {\\n      undo: () => {\\n        if (historyIndex > 0) {\\n          historyIndex--;\\n          set(history[historyIndex]);\\n        }\\n      },\\n      redo: () => {\\n        if (historyIndex < history.length - 1) {\\n          historyIndex++;\\n          set(history[historyIndex]);\\n        }\\n      },\\n      getHistory: () => history,\\n    };\\n  }\\n\\n  return (next) => async (partial) => {\\n    await next(partial);\\n\\n    const newState = get();\\n    history = history.slice(0, historyIndex + 1);\\n    history.push(newState);\\n    historyIndex++;\\n\\n    console.log(`\u23f1\ufe0f History: ${historyIndex}/${history.length}`);\\n  };\\n};\\n```\\n\\nUse it: `window.__devtools__.undo()` and `window.__devtools__.redo()`\\n\\n### 4. Analytics Middleware\\n\\nTrack user actions:\\n\\n```typescript\\nconst analyticsMiddleware = (set, get) => (next) => async (partial) => {\\n  const state = get();\\n  const actionName = typeof partial === \'function\' ? \'update\' : Object.keys(partial)[0];\\n\\n  // Send to analytics\\n  fetch(\'/api/analytics\', {\\n    method: \'POST\',\\n    body: JSON.stringify({\\n      action: actionName,\\n      timestamp: Date.now(),\\n      previousState: state,\\n    }),\\n  });\\n\\n  await next(partial);\\n};\\n```\\n\\n### 5. Debounce Middleware\\n\\nDebounce frequent updates (useful for search, typing, etc.):\\n\\n```typescript\\nconst debounceMiddleware = (ms: number) => {\\n  let timeoutId: NodeJS.Timeout;\\n\\n  return (set, get) => (next) => async (partial) => {\\n    clearTimeout(timeoutId);\\n\\n    timeoutId = setTimeout(async () => {\\n      await next(partial);\\n      console.log(\'\u23f1\ufe0f Debounced update applied\');\\n    }, ms);\\n  };\\n};\\n\\n// Usage: Wait 300ms before updating search\\nconst useSearchStore = create(\\n  (set) => ({\\n    query: \'\',\\n    setQuery: (query: string) => set({ query }),\\n  }),\\n  debounceMiddleware(300)\\n);\\n```\\n\\n## Real-World Example\\n\\nLet\'s combine multiple middleware for a complete user store:\\n\\n```typescript\\ntype UserStore = {\\n  user: null | { id: number; email: string; name: string }\\n  isLoading: boolean\\n  error: null | string\\n  setUser: (user: any) => void\\n  logout: () => void\\n}\\n\\nconst useUserStore = create<UserStore>(\\n  (set, get) => {\\n    // Load persisted user\\n    const saved = localStorage.getItem(\'user\');\\n    const initialUser = saved ? JSON.parse(saved) : null;\\n\\n    return {\\n      user: initialUser,\\n      isLoading: false,\\n      error: null,\\n      \\n      setUser: (user) => set({ user }),\\n      logout: () => set({ user: null, error: null }),\\n    };\\n  },\\n  [\\n    // Logger first\\n    (set, get) => (next) => async (partial) => {\\n      console.log(\'Updating:\', partial);\\n      await next(partial);\\n    },\\n    \\n    // Validation\\n    (set, get) => (next) => async (partial) => {\\n      const updates = typeof partial === \'function\' ? partial(get()) : partial;\\n      if (\'user\' in updates && updates.user && !updates.user.email?.includes(\'@\')) {\\n        console.error(\'Invalid email\');\\n        return;\\n      }\\n      await next(partial);\\n    },\\n    \\n    // Persistence\\n    (set, get) => (next) => async (partial) => {\\n      await next(partial);\\n      if (\'user\' in get()) {\\n        localStorage.setItem(\'user\', JSON.stringify(get().user));\\n      }\\n    },\\n  ]\\n);\\n```\\n\\n## Best Practices\\n\\n### 1. Keep Middleware Pure\\n\\nMiddleware should not modify external state directly:\\n\\n```typescript\\n//  Good\\nconst middleware = (set, get) => (next) => async (partial) => {\\n  console.log(\'Updating\');\\n  await next(partial);\\n};\\n\\n//  Bad\\nlet counter = 0;\\nconst badMiddleware = (set, get) => (next) => async (partial) => {\\n  counter++; // Side effect!\\n  await next(partial);\\n};\\n```\\n\\n### 2. Call `next` Only Once\\n\\n```typescript\\n//  Good\\nconst middleware = (set, get) => (next) => async (partial) => {\\n  console.log(\'Before\');\\n  await next(partial);\\n  console.log(\'After\');\\n};\\n\\n//  Bad - causes issues\\nconst badMiddleware = (set, get) => (next) => async (partial) => {\\n  await next(partial);\\n  set(partial); // Calls middleware again!\\n};\\n```\\n\\n### 3. Order Matters\\n\\n```typescript\\n// This logs, then persists\\nconst store1 = create(initialState, [loggerMiddleware, persistenceMiddleware]);\\n\\n// This persists, then logs\\nconst store2 = create(initialState, [persistenceMiddleware, loggerMiddleware]);\\n\\n// Same middlewares, different behavior!\\n```\\n\\n### 4. Handle Errors Gracefully\\n\\n```typescript\\nconst safeMiddleware = (set, get) => (next) => async (partial) => {\\n  try {\\n    await next(partial);\\n  } catch (error) {\\n    console.error(\'Middleware error:\', error);\\n    // Handle gracefully - maybe revert state\\n  }\\n};\\n```\\n\\n## Performance Tips\\n\\n### 1. Keep Middleware Lightweight\\n\\nAvoid heavy computations inside middleware:\\n\\n```typescript\\n//  Lightweight\\nconst middleware = (set, get) => (next) => async (partial) => {\\n  console.log(\'Update\');\\n  await next(partial);\\n};\\n\\n//  Heavy computation\\nconst heavyMiddleware = (set, get) => (next) => async (partial) => {\\n  const result = await runExpensiveCalculation();\\n  await next(partial);\\n};\\n```\\n\\n### 2. Consider Conditional Middleware\\n\\n```typescript\\nconst conditionalLogger = \\n  process.env.NODE_ENV === \'development\' \\n    ? loggerMiddleware \\n    : (set, get) => (next) => (partial) => next(partial);\\n\\nconst useStore = create(initialState, conditionalLogger);\\n```\\n\\n## Testing Middleware\\n\\n```typescript\\ndescribe(\'loggerMiddleware\', () => {\\n  it(\'should log state changes\', async () => {\\n    const logs: any[] = [];\\n    const originalLog = console.log;\\n    console.log = (...args) => logs.push(args);\\n\\n    const useStore = create(\\n      (set) => ({\\n        count: 0,\\n        increment: () => set((state) => ({ count: state.count + 1 })),\\n      }),\\n      (set, get) => (next) => async (partial) => {\\n        console.log(\'Updating:\', partial);\\n        await next(partial);\\n      }\\n    );\\n\\n    useStore.setState((state) => ({ count: state.count + 1 }));\\n\\n    expect(logs.length).toBeGreaterThan(0);\\n    console.log = originalLog;\\n  });\\n});\\n```\\n\\n## Conclusion\\n\\nZustic middleware provides a clean, functional approach to extending state management:\\n\\n **Simple** - Easy to understand and create\\n **Composable** - Chain multiple middleware together\\n **Powerful** - Handle logging, persistence, validation, and more\\n **Flexible** - Create custom middleware for any use case\\n\\nStart using middleware to build more robust, observable, and maintainable state management!\\n\\n**Next Steps:**\\n- Check out the [Middleware Guide](/docs/tutorial-extras/middleware) for complete documentation\\n- See [Advanced Examples](/docs/tutorial-extras/advanced-examples) for complex middleware patterns\\n- Read our [Best Practices](/docs/tutorial-extras/best-practices) guide"}]}}')}}]);