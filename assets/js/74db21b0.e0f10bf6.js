"use strict";(globalThis.webpackChunkzustic_doc=globalThis.webpackChunkzustic_doc||[]).push([[9457],{9720(e,n,a){a.r(n),a.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"tutorial-extras/query-advanced","title":"Advanced Features & Optimization","description":"Master caching strategies, performance optimization, and advanced patterns","source":"@site/docs/tutorial-extras/query-advanced.md","sourceDirName":"tutorial-extras","slug":"/tutorial-extras/query-advanced","permalink":"/docs/tutorial-extras/query-advanced","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/tutorial-extras/query-advanced.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5,"title":"Advanced Features & Optimization","description":"Master caching strategies, performance optimization, and advanced patterns"},"sidebar":"tutorialSidebar","previous":{"title":"Plugins","permalink":"/docs/tutorial-extras/query-plugins"},"next":{"title":"Zustic vs Other State Management Libraries","permalink":"/docs/tutorial-extras/comparison"}}');var r=a(4848),s=a(8453);const i={sidebar_position:5,title:"Advanced Features & Optimization",description:"Master caching strategies, performance optimization, and advanced patterns"},o="Advanced Features & Optimization",d={},l=[{value:"Caching Architecture",id:"caching-architecture",level:2},{value:"Cache Flow &amp; Behavior",id:"cache-flow--behavior",level:3},{value:"Cache Configuration Strategies",id:"cache-configuration-strategies",level:3},{value:"Real-Time Data (Short Cache)",id:"real-time-data-short-cache",level:4},{value:"Stable Data (Long Cache)",id:"stable-data-long-cache",level:4},{value:"Always Fresh (No Cache)",id:"always-fresh-no-cache",level:4},{value:"Manual Cache Invalidation",id:"manual-cache-invalidation",level:2},{value:"Refresh Button Example",id:"refresh-button-example",level:3},{value:"Data Transformation",id:"data-transformation",level:2},{value:"Response Normalization",id:"response-normalization",level:3},{value:"Error Handling &amp; Recovery",id:"error-handling--recovery",level:2},{value:"Error Normalization",id:"error-normalization",level:3},{value:"Automatic Retry with Exponential Backoff",id:"automatic-retry-with-exponential-backoff",level:3},{value:"Sequential Data Dependencies",id:"sequential-data-dependencies",level:2},{value:"Multi-Step Data Loading",id:"multi-step-data-loading",level:3},{value:"Real-Time Data Updates",id:"real-time-data-updates",level:2},{value:"Polling Implementation",id:"polling-implementation",level:3},{value:"Optimized Network Requests",id:"optimized-network-requests",level:2},{value:"Batching Multiple Resources",id:"batching-multiple-resources",level:3},{value:"Computational Memoization",id:"computational-memoization",level:2},{value:"Memoizing Derived State",id:"memoizing-derived-state",level:3},{value:"Conditional Query Execution",id:"conditional-query-execution",level:2},{value:"Permission &amp; Feature-Based Loading",id:"permission--feature-based-loading",level:3},{value:"Best Practices &amp; Anti-Patterns",id:"best-practices--anti-patterns",level:2},{value:"Recommended Patterns",id:"recommended-patterns",level:3},{value:"Anti-Patterns to Avoid",id:"anti-patterns-to-avoid",level:3},{value:"Manual Query Data Updates",id:"manual-query-data-updates",level:2},{value:"Updating Query Cache",id:"updating-query-cache",level:3},{value:"Bulk Data Mutations",id:"bulk-data-mutations",level:3}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"advanced-features--optimization",children:"Advanced Features & Optimization"})}),"\n",(0,r.jsx)(n.p,{children:"Learn advanced techniques for building performant, scalable server state management with Zustic Query."}),"\n",(0,r.jsx)(n.h2,{id:"caching-architecture",children:"Caching Architecture"}),"\n",(0,r.jsx)(n.p,{children:"Zustic Query uses an intelligent time-based caching system where each endpoint maintains its own cache expiration timer, allowing fine-grained control over data freshness and network efficiency."}),"\n",(0,r.jsx)(n.h3,{id:"cache-flow--behavior",children:"Cache Flow & Behavior"}),"\n",(0,r.jsx)(n.p,{children:"The caching mechanism follows a predictable lifecycle:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  cacheTimeout: 5 * 60 * 1000,  // Cache for 5 minutes\n  endpoints: (builder) => ({\n    getUsers: builder.query({\n      query: () => ({ url: '/users' })\n    })\n  })\n})\n\n// First call: Network request, store in cache\nconst { data: users1 } = useGetUsersQuery()\n\n// Within 5 minutes: Return cached data instantly\nconst { data: users2 } = useGetUsersQuery()\n\n// After 5 minutes: Fetch fresh data\nconst { data: users3 } = useGetUsersQuery()\n\n// Manual refetch: Bypass cache immediately\nconst { reFetch } = useGetUsersQuery()\nreFetch()  // Always fetches fresh\n"})}),"\n",(0,r.jsx)(n.h3,{id:"cache-configuration-strategies",children:"Cache Configuration Strategies"}),"\n",(0,r.jsx)(n.h4,{id:"real-time-data-short-cache",children:"Real-Time Data (Short Cache)"}),"\n",(0,r.jsx)(n.p,{children:"For frequently changing data, use a short cache window:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  cacheTimeout: 1 * 60 * 1000,  // 1 minute\n  endpoints: (builder) => ({\n    getLiveStats: builder.query({\n      query: () => ({ url: '/stats' })\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h4,{id:"stable-data-long-cache",children:"Stable Data (Long Cache)"}),"\n",(0,r.jsx)(n.p,{children:"For reference data that rarely changes, use extended cache durations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  cacheTimeout: 30 * 60 * 1000,  // 30 minutes\n  endpoints: (builder) => ({\n    getCountries: builder.query({\n      query: () => ({ url: '/countries' })\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h4,{id:"always-fresh-no-cache",children:"Always Fresh (No Cache)"}),"\n",(0,r.jsx)(n.p,{children:"For data that must always be current, disable caching entirely:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const api = createApi({\n  baseQuery: myBaseQuery,\n  cacheTimeout: 0,  // Disable cache\n  endpoints: (builder) => ({\n    getRandomNumber: builder.query({\n      query: () => ({ url: '/random' })\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h2,{id:"manual-cache-invalidation",children:"Manual Cache Invalidation"}),"\n",(0,r.jsxs)(n.p,{children:["Use ",(0,r.jsx)(n.code,{children:"reFetch()"})," to bypass the cache and retrieve fresh data immediately. This is essential for operations like user-initiated refreshes or after data modifications."]}),"\n",(0,r.jsx)(n.h3,{id:"refresh-button-example",children:"Refresh Button Example"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export function UsersList() {\n  const { data, reFetch, isLoading } = useGetUsersQuery()\n\n  const handleRefresh = () => {\n    reFetch()  // Bypass cache, fetch fresh data\n  }\n\n  return (\n    <div>\n      <button onClick={handleRefresh} disabled={isLoading}>\n        {isLoading ? 'Refreshing...' : ' Refresh'}\n      </button>\n      <ul>\n        {data?.map(user => <li key={user.id}>{user.name}</li>)}\n      </ul>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"data-transformation",children:"Data Transformation"}),"\n",(0,r.jsx)(n.p,{children:"Transform API responses into application-specific formats, enabling clean separation between server contracts and application logic."}),"\n",(0,r.jsx)(n.h3,{id:"response-normalization",children:"Response Normalization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"interface ApiUser {\n  id: number\n  first_name: string\n  last_name: string\n  created_at: string\n}\n\ninterface AppUser {\n  id: number\n  fullName: string\n  joinDate: Date\n}\n\nendpoints: (builder) => ({\n  getUser: builder.query({\n    query: (id) => ({ url: `/users/${id}` }),\n\n    // Transform API format to app format\n    transformResponse: (data: ApiUser): AppUser => {\n      return {\n        id: data.id,\n        fullName: `${data.first_name} ${data.last_name}`,\n        joinDate: new Date(data.created_at)\n      }\n    }\n  })\n})\n\n// Component receives transformed data\nexport function UserDetail({ userId }: { userId: number }) {\n  const { data: user } = useGetUserQuery(userId)\n\n  return (\n    <div>\n      <h1>{user?.fullName}</h1>\n      <p>Joined: {user?.joinDate.toLocaleDateString()}</p>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling--recovery",children:"Error Handling & Recovery"}),"\n",(0,r.jsx)(n.p,{children:"Implement robust error handling with transformation and automatic retry strategies."}),"\n",(0,r.jsx)(n.h3,{id:"error-normalization",children:"Error Normalization"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"endpoints: (builder) => ({\n  getUser: builder.query({\n    query: (id) => ({ url: `/users/${id}` }),\n\n    // Normalize error messages\n    transformError: (error: string) => {\n      if (error.includes('404')) return 'User not found'\n      if (error.includes('401')) return 'Unauthorized'\n      if (error.includes('500')) return 'Server error'\n      return 'An error occurred'\n    }\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h3,{id:"automatic-retry-with-exponential-backoff",children:"Automatic Retry with Exponential Backoff"}),"\n",(0,r.jsx)(n.p,{children:"Improve reliability by automatically retrying failed requests with progressive delays:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const retryMiddleware = async (ctx, next) => {\n  let lastError\n\n  // Try up to 3 times\n  for (let i = 0; i < 3; i++) {\n    const result = await next()\n\n    if (!result.error) {\n      return result\n    }\n\n    lastError = result.error\n\n    // Exponential backoff: 1s, 2s, 4s\n    if (i < 2) {\n      await new Promise(r => setTimeout(r, Math.pow(2, i) * 1000))\n    }\n  }\n\n  return { error: lastError }\n}\n\nconst api = createApi({\n  baseQuery: myBaseQuery,\n  middlewares: [retryMiddleware],\n  endpoints: (builder) => ({\n    getUser: builder.query({\n      query: (id) => ({ url: `/users/${id}` })\n    })\n  })\n})\n"})}),"\n",(0,r.jsx)(n.h2,{id:"sequential-data-dependencies",children:"Sequential Data Dependencies"}),"\n",(0,r.jsx)(n.p,{children:"Implement dependent query patterns where subsequent requests only execute after prerequisite data is loaded, preventing unnecessary network overhead."}),"\n",(0,r.jsx)(n.h3,{id:"multi-step-data-loading",children:"Multi-Step Data Loading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"export function UserPosts({ userId }: { userId: number }) {\n  // First query: fetch user\n  const { data: user } = useGetUserQuery(userId)\n\n  // Second query: depends on user being loaded\n  const { data: posts } = useGetUserPostsQuery(user?.id ?? 0, {\n    skip: !user  // Skip until user is loaded\n  })\n\n  return (\n    <div>\n      <h1>{user?.name}</h1>\n      {posts?.map(post => (\n        <article key={post.id}>{post.title}</article>\n      ))}\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"real-time-data-updates",children:"Real-Time Data Updates"}),"\n",(0,r.jsx)(n.p,{children:"Implement polling patterns for data that requires frequent refresh cycles, such as live statistics or status feeds."}),"\n",(0,r.jsx)(n.h3,{id:"polling-implementation",children:"Polling Implementation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { useEffect } from 'react'\n\nexport function LiveStats() {\n  const { data: stats, reFetch } = useGetStatsQuery()\n\n  // Poll every 5 seconds\n  useEffect(() => {\n    const interval = setInterval(() => {\n      reFetch()\n    }, 5000)\n\n    return () => clearInterval(interval)\n  }, [reFetch])\n\n  return <div>Count: {stats?.count}</div>\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"optimized-network-requests",children:"Optimized Network Requests"}),"\n",(0,r.jsx)(n.p,{children:"Reduce network overhead and improve performance by batching multiple individual requests into single batch operations."}),"\n",(0,r.jsx)(n.h3,{id:"batching-multiple-resources",children:"Batching Multiple Resources"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"// Problem: Multiple individual requests\nexport function Users() {\n  const { data: user1 } = useGetUserQuery(1)\n  const { data: user2 } = useGetUserQuery(2)\n  const { data: user3 } = useGetUserQuery(3)\n  // 3 separate requests\n}\n\n// Solution: Batch endpoint\nconst api = createApi({\n  baseQuery: myBaseQuery,\n  endpoints: (builder) => ({\n    getUsersBatch: builder.query({\n      query: (ids: number[]) => ({\n        url: '/users/batch',\n        method: 'POST',\n        body: { ids }\n      })\n    })\n  })\n})\n\nexport function Users() {\n  const { data: users } = useGetUsersBatchQuery([1, 2, 3])\n  // 1 request for all users\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"computational-memoization",children:"Computational Memoization"}),"\n",(0,r.jsx)(n.p,{children:"Cache expensive computations to prevent redundant calculations across re-renders, improving application responsiveness and memory efficiency."}),"\n",(0,r.jsx)(n.h3,{id:"memoizing-derived-state",children:"Memoizing Derived State"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-jsx",children:"import { useMemo } from 'react'\n\nexport function UsersList() {\n  const { data: users } = useGetUsersQuery()\n\n  // Memoize expensive computations\n  const sortedUsers = useMemo(() => {\n    return users?.sort((a, b) => a.name.localeCompare(b.name)) || []\n  }, [users])\n\n  const usersByRole = useMemo(() => {\n    return users?.reduce((acc, user) => {\n      if (!acc[user.role]) acc[user.role] = []\n      acc[user.role].push(user)\n      return acc\n    }, {} as Record<string, any>) || {}\n  }, [users])\n\n  return <UserTable sorted={sortedUsers} byRole={usersByRole} />\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"conditional-query-execution",children:"Conditional Query Execution"}),"\n",(0,r.jsx)(n.p,{children:"Control which queries execute based on runtime conditions, permissions, or feature flags, optimizing resource usage and enabling progressive feature rollout."}),"\n",(0,r.jsx)(n.h3,{id:"permission--feature-based-loading",children:"Permission & Feature-Based Loading"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export function Dashboard() {\n  // Only fetch if admin\n  const isAdmin = useIsAdmin()\n\n  const { data: analytics } = useGetAnalyticsQuery(undefined, {\n    skip: !isAdmin\n  })\n\n  // A/B testing\n  const useNewUI = useFeatureFlag('new-ui')\n\n  const { data: legacyData } = useGetPostsQuery(undefined, {\n    skip: useNewUI\n  })\n\n  const { data: modernData } = useGetPostsV2Query(undefined, {\n    skip: !useNewUI\n  })\n\n  return <Dashboard data={modernData || legacyData} analytics={analytics} />\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices--anti-patterns",children:"Best Practices & Anti-Patterns"}),"\n",(0,r.jsx)(n.p,{children:"Follow these patterns to build robust, performant applications."}),"\n",(0,r.jsx)(n.h3,{id:"recommended-patterns",children:"Recommended Patterns"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Use ",(0,r.jsx)(n.code,{children:"skip"})," option for conditional queries"]}),"\n",(0,r.jsxs)(n.li,{children:["Call ",(0,r.jsx)(n.code,{children:"reFetch()"})," to manually refetch when needed"]}),"\n",(0,r.jsx)(n.li,{children:"Transform responses for your app's data format"}),"\n",(0,r.jsxs)(n.li,{children:["Use appropriate ",(0,r.jsx)(n.code,{children:"cacheTimeout"})," values"]}),"\n",(0,r.jsx)(n.li,{children:"Handle errors in component UI"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"anti-patterns-to-avoid",children:"Anti-Patterns to Avoid"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["Don't call hooks conditionally (use ",(0,r.jsx)(n.code,{children:"skip"})," instead)"]}),"\n",(0,r.jsx)(n.li,{children:"Don't create API instances inside components"}),"\n",(0,r.jsx)(n.li,{children:"Don't forget to handle loading states"}),"\n",(0,r.jsxs)(n.li,{children:["Don't pass ",(0,r.jsx)(n.code,{children:"undefined"})," as query arguments"]}),"\n",(0,r.jsx)(n.li,{children:"Don't ignore error states in UI"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"manual-query-data-updates",children:"Manual Query Data Updates"}),"\n",(0,r.jsxs)(n.p,{children:["Update cached query data programmatically without refetching, enabling optimistic updates, real-time synchronization, and complex state mutations. The ",(0,r.jsx)(n.code,{children:"updateQueryData"})," utility provides direct access to mutate cached data."]}),"\n",(0,r.jsx)(n.h3,{id:"updating-query-cache",children:"Updating Query Cache"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"export function UpdateUserEmail() {\n  const [email, setEmail] = useState('')\n  const { mutate: updateUser } = useUpdateUserMutation()\n  \n  const handleSubmit = async () => {\n    try {\n      const result = await updateUser({ email }).unwrap()\n      \n      // Manually update the cached query data\n      api.utils.updateQueryData('getUser', { page: 1, limit: 10 }, (draft) => {\n        draft = draft.map(d => ({\n          ...d,\n          email: email\n        }))\n        return draft\n      })\n      \n      setEmail('')\n    } catch (error) {\n      console.error('Failed to update:', error)\n    }\n  }\n\n  return (\n    <div>\n      <input\n        value={email}\n        onChange={(e) => setEmail(e.target.value)}\n        placeholder=\"New email\"\n      />\n      <button onClick={handleSubmit}>Update Email</button>\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"bulk-data-mutations",children:"Bulk Data Mutations"}),"\n",(0,r.jsx)(n.p,{children:"Transform entire dataset with complex logic:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Remove user from cached list\napi.utils.updateQueryData('getUsers', undefined, (draft) => {\n  return draft.filter(user => user.id !== userId)\n})\n\n// Sort cached users\napi.utils.updateQueryData('getUsers', undefined, (draft) => {\n  draft.sort((a, b) => a.name.localeCompare(b.name))\n  return draft\n})\n\n// Add new item to cached list\napi.utils.updateQueryData('getUsers', undefined, (draft) => {\n  draft.push(newUser)\n  return draft\n})\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},8453(e,n,a){a.d(n,{R:()=>i,x:()=>o});var t=a(6540);const r={},s=t.createContext(r);function i(e){const n=t.useContext(s);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);